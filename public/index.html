<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<title>three.js webgl - io - scene loader</title>

		<!-- CSS -->
		<link rel="stylesheet" type="text/css" href="css/base.css">
	</head>

	<body>
		<div id="info">
			<a href="http://threejs.org">three.js</a> - scene loader test
		</div>

		<div id="scene_explorer">
			<a id="plus_exp" href="#">[+]</a>
			<div id="section_exp"></div>
		</div>

		<div id="progress">
			<span id="message">Loading ...</span>

			<center>
				<div id="progressbar" class="shadow"><div id="bar" class="shadow"></div></div>
				<div id="start" class="disabled">Start</div>
			</center>
		</div>


		<div id="blocker">

            <div id="instructions">
                <span style="font-size:40px">Click to play</span>
                <br />
                (W,A,S,D = Move, SPACE = Jump, MOUSE = Look, CLICK+HOLD = Shoot)
            </div>

        </div>

		<script src="libs/three.min.js"></script>
		<script src="libs/loaders/lzma.js"></script>
		<script src="libs/loaders/ctm.js"></script>
		<script src="libs/loaders/CTMLoader.js"></script>
		<script src="libs/loaders/BinaryLoader.js"></script>
		<script src="libs/loaders/OBJLoader.js"></script>
		<script src="libs/loaders/VTKLoader.js"></script>
		<script src="libs/loaders/STLLoader.js"></script>
		<script src="libs/loaders/ColladaLoader.js"></script>
		<script src="libs/loaders/UTF8Loader.js"></script>
		<script src="libs/loaders/MTLLoader.js"></script>
		<script src="libs/loaders/OBJMTLLoader.js"></script>
		<script src="libs/Detector.js"></script>
		<script src="libs/stats.min.js"></script>
		<script src="libs/PointerLockControls.js"></script>
		<script src="libs/THREEx.screenshot.js"></script>

		<script>

			var blocker = document.getElementById( 'blocker' );
			var instructions = document.getElementById( 'instructions' );

			function initBlenderScene() {

				//////////////////////////////
				// ** -- POINTER LOCK -- ** //
				//////////////////////////////

				var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

				if ( havePointerLock ) {
					
					var element = document.body;	
					var pointerlockchange = function ( event ) {
					
					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
					
						console.log('controls true');
						controls.enabled = true;
						blocker.style.display = 'none';
					
					} else {
					
						console.log('controls false');
						controls.enabled = false;
						blocker.style.display = 'block';
						instructions.style.display = 'block';
					
					}
				}

				// var controls = new PointerLockControls( camera );
                // scene.add( controls.getObject() );

				var pointerlockerror = function ( event ) {
				  instructions.style.display = '';
				}
				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

				document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

				instructions.addEventListener( 'click', function ( event ) {
				  instructions.style.display = 'none';

				  // Ask the browser to lock the pointer
				  element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
				  if ( /Firefox/i.test( navigator.userAgent ) ) {
				    var fullscreenchange = function ( event ) {
				      if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
				        document.removeEventListener( 'fullscreenchange', fullscreenchange );
				        document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
				        element.requestPointerLock();
				      }
				    }

				    document.addEventListener( 'fullscreenchange', fullscreenchange, false );
				    document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

				    element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
				    element.requestFullscreen();
				  } else {
				    element.requestPointerLock();
				  }
				}, false );
				} else {
					instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
				}
			}

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

				var SCREEN_WIDTH = window.innerWidth;
				var SCREEN_HEIGHT = window.innerHeight;

				var container,stats;

				var camera, scene, loaded;
				var renderer;

				var currentScene;

				var controls = Date.now();
				var time = controls;

				var mouseX = 0, mouseY = 0;

				var windowHalfX = window.innerWidth / 2;
				var windowHalfY = window.innerHeight / 2;

				var rotatingObjects = [];
				var morphAnimatedObjects = [];

				var clock = new THREE.Clock();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			THREE.DefaultLoadingManager.onProgress = function ( item, loaded, total ) {

				console.log( item, loaded, total );

			};

			init();
			animate();

			function $( id ) {

				return document.getElementById( id );

			}

			function handle_update( result, pieces ) {

				refreshSceneView( result );
				//renderer.initWebGLObjects( result.scene );

				var m, material, count = 0;

				for ( m in result.materials ) {

					material = result.materials[ m ];
					if ( ! ( material instanceof THREE.MeshFaceMaterial || material instanceof THREE.ShaderMaterial || material.morphTargets ) ) {

						if( !material.program ) {

							renderer.initMaterial( material, result.scene.__lights, result.scene.fog );

							count += 1;

							if( count > pieces ) {

								//console.log("xxxxxxxxx");
								break;

							}

						}

					}

				}

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// creates the first scene you see
				// width the loading bar
				// createLoadScene returns an object with
				// a new THREE camera and scene
				var loadScene = createLoadScene();
				currentScene = 0;

				// sets the camera and scene variables
				// returned from createLoadScene
				camera = loadScene.camera;
				scene = loadScene.scene;

				// creates the canvas of the first scene
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				renderer.domElement.style.position = "relative";

				// appends renderer canvas to container
				container.appendChild( renderer.domElement );

				// sets some parameters on renderer canvas
				// not exactly sure what they mean
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.physicallyBasedShading = true;

				// creates the stats frame output
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.right = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

				// create the event listener for start
				$( "start" ).addEventListener( 'click', onStartClick, false );

				var callbackProgress = function( progress, result ) {

					var bar = 250,
						total = progress.totalModels + progress.totalTextures,
						loaded = progress.loadedModels + progress.loadedTextures;

					if ( total )
						bar = Math.floor( bar * loaded / total );

					$( "bar" ).style.width = bar + "px";

					count = 0;
					for ( var m in result.materials ) count++;

					handle_update( result, Math.floor( count/total ) );

				}

				var callbackSync = function( result ) {

					/*

					// uncomment to see progressive scene loading

					scene = result.scene;
					camera = result.currentCamera;

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					*/

					//handle_update( result, 1 );

				}

				var callbackFinished = function ( result ) {

					loaded = result;

					$( "message" ).style.display = "none";
					$( "progressbar" ).style.display = "none";
					$( "start" ).style.display = "block";
					$( "start" ).className = "enabled";

					handle_update( result, 1 );

					result.scene.traverse( function ( object ) {

						if ( object.userData.rotating === true ) {

							rotatingObjects.push( object );

						}

						if ( object instanceof THREE.MorphAnimMesh ) {

							morphAnimatedObjects.push( object );

						}

						if ( object instanceof THREE.SkinnedMesh ) {

							if ( object.geometry.animation ) {

								THREE.AnimationHandler.add( object.geometry.animation );

								var animation = new THREE.Animation( object, object.geometry.animation.name );
								animation.JITCompile = false;
								animation.interpolationType = THREE.AnimationHandler.LINEAR;

								animation.play();

							}

						}

					} );

				}

				// actual progress bar
				$( "progress" ).style.display = "block";

				var loader = new THREE.SceneLoader();

				// adds the different types of geometries
				// the loader will understand
				loader.addGeometryHandler( "binary", THREE.BinaryLoader );
				loader.addGeometryHandler( "ctm", THREE.CTMLoader );
				loader.addGeometryHandler( "vtk", THREE.VTKLoader );
				loader.addGeometryHandler( "stl", THREE.STLLoader );

				// adds the different types of Hierarchies
				// the loader will understand
				
				// what is the difference between GeometryHandler & HierarchyHandler?
				// does hierarchy mean that they load first?
				loader.addHierarchyHandler( "obj", THREE.OBJLoader );
				loader.addHierarchyHandler( "dae", THREE.ColladaLoader );
				loader.addHierarchyHandler( "utf8", THREE.UTF8Loader );


				loader.callbackSync = callbackSync;
				loader.callbackProgress = callbackProgress;

				loader.load( "scenes/gallery404_scene.js", callbackFinished );

				// adds a click event listener on the explore dropdown
				// in the top left corner
				$( "plus_exp" ).addEventListener( 'click', createToggle( "exp" ), false );

				// at end of init function listens for window resize 
				// and triggers the onWindowResize function
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function setButtonActive( id ) {

				$( "start" ).style.backgroundColor = "green";

			}

			function onStartClick() {

				$( "progress" ).style.display = "none";

				blocker.style.display = '-webkit-box';
                blocker.style.display = '-moz-box';
                blocker.style.display = 'box';

                instructions.style.display = '';

				
				// loads example scene
				
					// camera = loaded.currentCamera;
					// camera.aspect = window.innerWidth / window.innerHeight;
					// camera.updateProjectionMatrix();
					// scene = loaded.scene;
				

                ////////////////////////////////////
				//** -- ENVIRONMENT ELEMENTS -- **//
				////////////////////////////////////
				
				//var camera, scene, renderer;
				//var geometry, material, mesh;
				// var controls = Date.now();
				// var time = Date.now;
				// var objects = [];
				// var ray; 

                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                console.log( camera );

                scene = new THREE.Scene();
                scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
                
                controls = new THREE.PointerLockControls( camera );
                scene.add( controls.getObject() );

                geometry = new THREE.PlaneGeometry( 1250, 1250, 100, 100 );
                geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

                material = new THREE.MeshLambertMaterial({
                	map: THREE.ImageUtils.loadTexture('gallery_assets/textures/marble.png')
                });


                var light = new THREE.DirectionalLight( 0xffffff, 1.5 );
                light.position.set( 1, 1, 1 );
                scene.add( light );
                var light = new THREE.DirectionalLight( 0xffffff, 0.75 );
                light.position.set( -1, - 0.5, -1 );
                scene.add( light );
                
                ray = new THREE.Raycaster();
                ray.ray.direction.set( 0, -1, 0 );
                mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );


                initBlenderScene();
				//startGallery404();


			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );

			}

			function createLoadScene() {

				// this function returns an object with
				// a new THREE scene and perspective camera
				var result = {

					scene:  new THREE.Scene(),
					camera: new THREE.PerspectiveCamera( 65, window.innerWidth / window.innerHeight, 1, 1000 )

				};

				// sets the camera deph position in the loadingScene
				result.camera.position.z = 100;

				// not sure what this does, seems to not affect the code
				result.scene.add( result.camera );

				// sets the amount of variables and quantity of cubes in the loadingScene
				var object, geometry, material, light, count = 500, range = 200;

				// creates the color and cube size that gets used in
				// in the for loop
				material = new THREE.MeshLambertMaterial( { color:0xffffff } );
				geometry = new THREE.CubeGeometry( 5, 5, 5 );


				// for loop that creates the cubes for the loading scene
				for( var i = 0; i < count; i++ ) {

					object = new THREE.Mesh( geometry, material );

					object.position.x = ( Math.random() - 0.5 ) * range;
					object.position.y = ( Math.random() - 0.5 ) * range;
					object.position.z = ( Math.random() - 0.5 ) * range;

					object.rotation.x = Math.random() * 6;
					object.rotation.y = Math.random() * 6;
					object.rotation.z = Math.random() * 6;

					object.matrixAutoUpdate = false;
					object.updateMatrix();

					// adds all objects to the loadingScene
					result.scene.add( object );

				}

				// not sure what this does,
				// doesnt seem to affect anything when commented out
				result.scene.matrixAutoUpdate = false;

				// creates 500 lights?
				light = new THREE.PointLight( 0xffffff );
				result.scene.add( light );

				// creates 1 directional light
				light = new THREE.DirectionalLight( 0x111111 );
				light.position.x = 1;
				result.scene.add( light );

				// returns a result object with 
				// the cubes camera, and scene
				return result;

			}

			//

			function animate() {
				console.log(currentScene);
				requestAnimationFrame( animate );
				//render();
				if (currentScene == 0){
                    //renderLoadScene();
                    render();
                    stats.update();
                }


				if (currentScene == 1){

					console.log('currentScene = 1');
    			     
    				// if(controls.enabled){
    			 	// 		world.step(dt);
    			 	// }
			
    			    controls.update( Date.now() - time );
    			    
    			    // render( scene, camera );
    			    render();

    			    time = Date.now();
			
    			}


				stats.update();

			}

			function render() {

				var delta = clock.getDelta();

				// renders the camera position for the loadedScene
				camera.position.x += ( mouseX - camera.position.x ) * .001;
				camera.position.y += ( - mouseY - camera.position.y ) * .001;

				// sets the point of focus on "scene position"
				// and the camera revolves around
				camera.lookAt( scene.position );

				
				// updates animation for both
				// the loadingScene and loadedScene
				// update skinning
				THREE.AnimationHandler.update( delta * 0.75 );

				for ( var i = 0; i < rotatingObjects.length; i ++ ) {

					var object = rotatingObjects[ i ];

					if ( object.userData.rotateX ) object.rotation.x += 1 * delta;
					if ( object.userData.rotateY ) object.rotation.y += 0.5 * delta;

				}

				for ( var i = 0; i < morphAnimatedObjects.length; i ++ ) {

					var object = morphAnimatedObjects[ i ];

					object.updateAnimation( 1000 * delta );

				}

				// renders the scene and camera for both
				// the loadingScene and loadedScene
				renderer.render( scene, camera );

			}

			function renderLoadScene() {

                camera.position.x += ( mouseX - camera.position.x ) * .001;
                camera.position.y += ( - mouseY - camera.position.y ) * .001;

                camera.lookAt( scene.position );

                renderer.render( scene, camera );

            }

			// Scene explorer user interface
			function toggle( id ) {

				var scn = $( "section_" + id ).style,
					btn = $( "plus_" + id );

				if ( scn.display == "block" ) {

					scn.display = "none";
					btn.innerHTML = "[+]";

				}
				else {

					scn.display = "block";
					btn.innerHTML = "[-]";

				}

			}

			function createToggle( label ) { return function() { toggle( label ) } };

			function refreshSceneView( result ) {

				$( "section_exp" ).innerHTML = generateSceneView( result );

				var config = [ "obj", "geo", "mat", "tex", "lit", "cam" ];

				for ( var i = 0; i < config.length; i++ )
					$( "plus_" + config[i] ).addEventListener( 'click', createToggle( config[i] ), false );

			}

			function generateSection( label, id, objects ) {

				var html = "";

				html += "<h3><a id='plus_" + id + "' href='#'>[+]</a> " + label + "</h3>";
				html += "<div id='section_" + id + "' class='part'>";

				for( var o in objects ) {

					html += o + "<br/>";

				}
				html += "</div>";

				return html;

			}

			function generateSceneView( result ) {

				var config = [
				[ "Objects",    "obj", result.objects ],
				[ "Geometries", "geo", result.geometries ],
				[ "Materials",  "mat", result.materials ],
				[ "Textures",   "tex", result.textures ],
				[ "Lights",     "lit", result.lights ],
				[ "Cameras",    "cam", result.cameras ]
				];

				var html = "";

				for ( var i = 0; i < config.length; i++ )
					html += generateSection( config[i][0], config[i][1], config[i][2] );

				return html;

			}

		/////////////////////////////
		//* -- INIT GALLERY404 -- *//
		/////////////////////////////

	    var startGallery404 = function() {

			var camera, scene, renderer;
			var geometry, material, mesh;
			var controls,time = Date.now();
			var objects = [];
			var ray;           
			// var blocker = document.getElementById( 'blocker' );
			// var instructions = document.getElementById( 'instructions' );

	  //       var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

			
			// if ( havePointerLock ) {
				
			// 	var element = document.body;
			// 	var pointerlockchange = function ( event ) {
				
			// 	if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
				
			// 		controls.enabled = true;
			// 		blocker.style.display = 'none';
				
			// 	} else {
				
			// 		controls.enabled = false;
			// 		blocker.style.display = 'block';
			// 		instructions.style.display = 'block';
				
			// 	}
			// }


			// var pointerlockerror = function ( event ) {
			//   instructions.style.display = '';
			// }
			// // Hook pointer lock state change events
			// document.addEventListener( 'pointerlockchange', pointerlockchange, false );
			// document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
			// document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

			// document.addEventListener( 'pointerlockerror', pointerlockerror, false );
			// document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
			// document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

			// instructions.addEventListener( 'click', function ( event ) {
			//   instructions.style.display = 'none';

			//   // Ask the browser to lock the pointer
			//   element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
			//   if ( /Firefox/i.test( navigator.userAgent ) ) {
			//     var fullscreenchange = function ( event ) {
			//       if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
			//         document.removeEventListener( 'fullscreenchange', fullscreenchange );
			//         document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
			//         element.requestPointerLock();
			//       }
			//     }

			//     document.addEventListener( 'fullscreenchange', fullscreenchange, false );
			//     document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

			//     element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
			//     element.requestFullscreen();
			//   } else {
			//     element.requestPointerLock();
			//   }
			// }, false );
			// } else {
			// 	instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
			// }


			function init() {

					////////////////////////////////////
					//** -- ENVIRONMENT ELEMENTS -- **//
					////////////////////////////////////

	                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
	                scene = new THREE.Scene();
	                scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
	                var light = new THREE.DirectionalLight( 0xffffff, 1.5 );
	                light.position.set( 1, 1, 1 );
	                scene.add( light );
	                var light = new THREE.DirectionalLight( 0xffffff, 0.75 );
	                light.position.set( -1, - 0.5, -1 );
	                scene.add( light );
	                controls = new THREE.PointerLockControls( camera );
	                scene.add( controls.getObject() );
	                ray = new THREE.Raycaster();
	                ray.ray.direction.set( 0, -1, 0 );

	                geometry = new THREE.PlaneGeometry( 1250, 1250, 100, 100 );
	                geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	                var material = new THREE.MeshLambertMaterial({
	                map: THREE.ImageUtils.loadTexture('gallery_assets/textures/marble.png')
	                });
	                mesh = new THREE.Mesh( geometry, material );
	                scene.add( mesh );
	                                

	                                  /////////////////////////////////
	                                  //** -- ART OBJECT MODELS -- **//
	                                  /////////////////////////////////


	                     //------------------- BRILLO BOXES -----------------//
	                     var materials = [
	                       new THREE.MeshLambertMaterial({
	                           map: THREE.ImageUtils.loadTexture('gallery_assets/textures/BrilloBox.png')
	                       }),
	                       new THREE.MeshLambertMaterial({
	                           map: THREE.ImageUtils.loadTexture('gallery_assets/textures/BrilloBox.png')
	                       }),
	                       new THREE.MeshLambertMaterial({
	                           map: THREE.ImageUtils.loadTexture('gallery_assets/textures/BrilloBoxTop.png')
	                       }),
	                       new THREE.MeshLambertMaterial({
	                           map: THREE.ImageUtils.loadTexture('gallery_assets/textures/BrilloBoxTop.png')
	                       }),
	                       new THREE.MeshLambertMaterial({
	                           map: THREE.ImageUtils.loadTexture('gallery_assets/textures/BrilloBox.png')
	                       }),
	                       new THREE.MeshLambertMaterial({
	                           map: THREE.ImageUtils.loadTexture('gallery_assets/textures/BrilloBox.png')
	                       })
	                     ];

	                     brillo = new THREE.Mesh(
	                          new THREE.CubeGeometry( 40,40,40 ),
	                          new THREE.MeshFaceMaterial( materials ) );
	                     brillo.position.y = 25;
	                     brillo.position.z = 400;
	                     brillo.position.x = -200;
	                     scene.add( brillo );
	                     objects.push ( brillo );

	                     brillo2 = brillo.clone();
	                     brillo2.position.y = 50;
	                     brillo2.position.z = 400;
	                     brillo2.position.x = -250;
	                     scene.add( brillo2 );
	                     objects.push ( brillo2 );

	                     brillo3 = brillo.clone();
	                     brillo3.position.y = 75;
	                     brillo3.position.z = 375;
	                     brillo3.position.x = -320;
	                     scene.add( brillo3 );
	                     objects.push ( brillo3 );

	                     brillo4 = brillo.clone();
	                     brillo4.position.y = 100;
	                     brillo4.position.z = 200;
	                     brillo4.position.x = -475;
	                     scene.add( brillo4 );
	                     objects.push ( brillo4 );

	                     brillo5 = brillo.clone();
	                     brillo5.position.y = 120;
	                     brillo5.position.z = 530;
	                     brillo5.position.x = -360;
	                     scene.add( brillo5 );
	                     objects.push ( brillo5 );

	                     brillo6 = brillo.clone();
	                     brillo6.position.y = 150;
	                     brillo6.position.z = 450;
	                     brillo6.position.x = -260;
	                     scene.add( brillo6 );
	                     objects.push ( brillo6 );

	                     brillo7 = brillo.clone();
	                     brillo7.position.y = 170;
	                     brillo7.position.z = 550;
	                     brillo7.position.x = -430;
	                     scene.add( brillo7 );
	                     objects.push ( brillo7 );

	                     brillo8 = brillo.clone();
	                     brillo8.position.y = 150;
	                     brillo8.position.z = 350;
	                     brillo8.position.x = -530;
	                     scene.add( brillo8 );
	                     objects.push ( brillo8 );

	                     brillo9 = brillo.clone();
	                     brillo9.position.y = 100;
	                     brillo9.position.z = 300;
	                     brillo9.position.x = -400;
	                     scene.add( brillo9 );
	                     objects.push ( brillo9 );

	                     brillo10 = brillo.clone();
	                     brillo10.position.y = 55;
	                     brillo10.position.z = 460;
	                     brillo10.position.x = -370;
	                     scene.add( brillo10 );
	                     objects.push ( brillo10 );

	                     brillo11 = brillo.clone();
	                     brillo11.position.y = 300;
	                     brillo11.position.z = 425;
	                     brillo11.position.x = -320;
	                     scene.add( brillo11 );
	                     objects.push ( brillo11 );

	                     brillo12 = brillo.clone();
	                     brillo12.position.y = 125;
	                     brillo12.position.z = 370;
	                     brillo12.position.x = -250;
	                     scene.add( brillo12 );
	                     objects.push ( brillo12 );

	                     brillo13 = brillo.clone();
	                     brillo13.position.y = 250;
	                     brillo13.position.z = 450;
	                     brillo13.position.x = -300;
	                     scene.add( brillo13 );
	                     objects.push ( brillo13 );

	                     brillo14 = brillo.clone();
	                     brillo14.position.y = 175;
	                     brillo14.position.z = 320;
	                     brillo14.position.x = -400;
	                     scene.add( brillo14 );
	                     objects.push ( brillo14 );

	                     brillo15 = brillo.clone();
	                     brillo15.position.y = 250;
	                     brillo15.position.z = 500;
	                     brillo15.position.x = -260;
	                     scene.add( brillo15 );
	                     objects.push ( brillo15 );

	                     brillo16 = brillo.clone();
	                     brillo16.position.y = 200;
	                     brillo16.position.z = 420;
	                     brillo16.position.x = -270;
	                     scene.add( brillo16 );
	                     objects.push ( brillo16 );

	                     brillo17 = brillo.clone();
	                     brillo17.position.y = 270;
	                     brillo17.position.z = 300;
	                     brillo17.position.x = -250;
	                     scene.add( brillo17 );
	                     objects.push ( brillo17 );

	                     brillo18 = brillo.clone();
	                     brillo18.position.y = 250;
	                     brillo18.position.z = 350;
	                     brillo18.position.x = -500;
	                     scene.add( brillo18 );
	                     objects.push ( brillo18 );

	                     brillo19 = brillo.clone();
	                     brillo19.position.y = 300;
	                     brillo19.position.z = 300;
	                     brillo19.position.x = -400;
	                     scene.add( brillo19 );
	                     objects.push ( brillo19 );

	                     brillo20 = brillo.clone();
	                     brillo20.position.y = 375;
	                     brillo20.position.z = 400;
	                     brillo20.position.x = -350;
	                     scene.add( brillo20 );
	                     objects.push ( brillo20 );

	                     brillo21 = brillo.clone();
	                     brillo21.position.y = 350;
	                     brillo21.position.z = 425;
	                     brillo21.position.x = -300;
	                     scene.add( brillo21 );
	                     objects.push ( brillo21 );
	                     
	                     bonusPlatform = new THREE.CubeGeometry( 120, 10, 120 );
	                     material = new THREE.MeshLambertMaterial( {ambient: 0xffffff} );

	                     var bonusMesh = new THREE.Mesh( bonusPlatform, material );
	                     bonusMesh.position.x = -300;
	                     bonusMesh.position.y = 400;
	                     bonusMesh.position.z = 500;
	                     scene.add( bonusMesh );
	                     objects.push( bonusMesh );

	                  var brilloMaterials = [
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshLambertMaterial({
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/warholCard.png' ) }),
	                  new THREE.MeshBasicMaterial( {} )
	                  ];

	                  brilloLabel = new THREE.Mesh(
	                  new THREE.CubeGeometry( 10, 5, 0.5),
	                  new THREE.MeshFaceMaterial( brilloMaterials ) );
	                  scene.add( brilloLabel );
	                  brilloLabel.position.y = 32.5;
	                  brilloLabel.position.x = -220;
	                  brilloLabel.position.z = 250;
	                  brilloLabel.rotation.y = 90;



	                  //------------------- DUCHAMP URINAL -----------------//

	                  var loader = new THREE.OBJMTLLoader();
	                  loader.addEventListener( 'load', function ( event ) {
	                      var object = event.content;
	                      object.position.y =  400;
	                      object.position.x = -300;
	                      object.position.z = 525;
	                      object.rotation.x = -Math.PI / 2; 
	                      object.rotation.z = -Math.PI; 
	                      object.scale.x = .8;
	                      object.scale.y = .8;
	                      object.scale.z = .8;
	                      scene.add( object );
	                  });
	                  loader.load( 'gallery_assets/models/Rmutt.obj', 'gallery_assets/models/Rmutt.mtl' );

	                  var duchampMaterials = [
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshLambertMaterial({
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/duchampCard.png' ) }),
	                  new THREE.MeshBasicMaterial( {} )
	                  ];

	                  duchampLabel = new THREE.Mesh(
	                  new THREE.CubeGeometry( 10, 5, 0.5),
	                  new THREE.MeshFaceMaterial( duchampMaterials ) );
	                  scene.add( duchampLabel );
	                  duchampLabel.position.y = 442.5;
	                  duchampLabel.position.x = -320;
	                  duchampLabel.position.z = 500;
	                  duchampLabel.rotation.y = -Math.PI; 

	                
	                  //------------------- ENDLESS TOWER -----------------//

	                  var loader = new THREE.ColladaLoader();
	                  var endlessTexture = new THREE.MeshLambertMaterial({
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/endlessTexture.png' ) 
	                  });
	                  loader.load('gallery_assets/models/endless.dae', function (result) {
	                      scene.add(result.scene);
	                      result.scene.position.y =  -10;
	                      result.scene.position.x =  -100;
	                      // result.scene.position.x =  0;
	                      // result.scene.position.z =  300;
	                      result.scene.scale.x = .3;
	                      result.scene.scale.y = .3;
	                      result.scene.scale.z = .3;
	                      result.scene.rotation.x = -Math.PI / 2;                   
	                  });

	                  var endlessMaterials = [
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshLambertMaterial({
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/endlessCard.png' ) }),
	                  new THREE.MeshBasicMaterial( {} )
	                  ];

	                  endlessLabel = new THREE.Mesh(
	                  new THREE.CubeGeometry( 10, 5, 0.5),
	                  new THREE.MeshFaceMaterial( endlessMaterials ) );
	                  scene.add( endlessLabel );
	                  endlessLabel.position.y = 32.5;
	                  endlessLabel.position.x = 500;
	                  endlessLabel.position.z = -100;
	                  endlessLabel.rotation.y = -Math.PI / 2;  


	                  //------------------- KOONS BALLOON DOG -----------------//


	                  var jsonLoader = new THREE.JSONLoader();
	                  jsonLoader.load( "gallery_assets/models/koons.js", addModelToScene );


	                  function addModelToScene( geometry, materials ) {
	                  var path = "gallery_assets/textures/cube/SwedishRoyalCastle/";
	                  var format = '.jpg';
	                  var urls = [
	                          path + 'px' + format, path + 'nx' + format,
	                          path + 'py' + format, path + 'ny' + format,
	                          path + 'pz' + format, path + 'nz' + format
	                      ];
	                  var reflectionCube = THREE.ImageUtils.loadTextureCube( urls );
	                  reflectionCube.format = THREE.RGBFormat;
	                  var refractionCube = new THREE.Texture( reflectionCube.image, new THREE.CubeRefractionMapping() );
	                  refractionCube.format = THREE.RGBFormat;
	                  var material = new THREE.MeshLambertMaterial( { color: 0xffee00, ambient: 0x996600,  envMap: reflectionCube, combine: THREE.MixOperation, reflectivity: 0.75} );

	                  koons = new THREE.Mesh( geometry, material );

	                  koons.scale.x = 10;
	                  koons.scale.y = 10;
	                  koons.scale.z = 10;
	                  koons.position.x = 5;
	                  koons.position.y = 15;
	                  koons.position.z = 150;
	                  scene.add(koons);

	                  function deflate() {
	                  setInterval(function() {
	                      if (koons.scale.x > 10 ) {
	                          koons.scale.x -= .1; 
	                          koons.scale.y -=.025;                    
	                      }
	                      else  if (koons.scale.x < 10){
	                          clearInterval();
	                          inflate();
	                      }
	                  }, 0050);
	                  }
	                  function inflate() {
	                  setInterval(function() {
	                      if (koons.scale.x < 20 ) {
	                          koons.scale.x += .1;
	                          koons.scale.y += .025;
	                      }
	                      else if (koons.scale.x > 20){
	                          clearInterval();
	                          deflate();
	                      }
	                  }, 0050);
	                  }
	                  inflate();
	                  }

	                  koonsPlatform = new THREE.CubeGeometry( 120, 10, 120 );

	                  var koonsMaterials = [
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshLambertMaterial({
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/koonsCard.png' ) }),
	                  new THREE.MeshBasicMaterial( {} )
	                  ];
	                  koonsLabel = new THREE.Mesh(
	                  new THREE.CubeGeometry( 10, 5, 0.5),
	                  new THREE.MeshFaceMaterial( koonsMaterials ) );
	                  scene.add( koonsLabel );
	                  koonsLabel.position.y = 32.5;
	                  koonsLabel.position.x = 45;
	                  koonsLabel.position.z = -279.5;

	                  material = new THREE.MeshBasicMaterial( {} );
	                  var mesh = new THREE.Mesh( koonsPlatform, material );
	                  mesh.position.x = -10;
	                  mesh.position.y = 10;
	                  mesh.position.z = -340;
	                  mesh.rotation.y = 0


	                  scene.add(mesh); 
	                  objects.push( mesh );


	                  //------------------- KRUGER WALL -----------------//

	                  var krugerMaterials = [
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshLambertMaterial({ }),
	                  new THREE.MeshBasicMaterial( { 
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/kruger1.png' )} )
	                  ];

	                  krugerWall = new THREE.Mesh(
	                  new THREE.CubeGeometry( 400, 600, 20),
	                  new THREE.MeshFaceMaterial( krugerMaterials ) );
	                  scene.add( krugerWall );
	                  krugerWall.position.y = 300;
	                  krugerWall.position.x = 435;
	                  krugerWall.position.z = 500;
	                  krugerWall.rotation.y = -125; 


	                  var krugerMaterials2 = [
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshLambertMaterial({ }),
	                  new THREE.MeshBasicMaterial( { 
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/kruger2.png' )} )
	                  ];

	                  krugerWall2 = new THREE.Mesh(
	                  new THREE.CubeGeometry( 400, 600, 20),
	                  new THREE.MeshFaceMaterial( krugerMaterials2 ) );
	                  krugerWall2.position.y = 300;
	                  krugerWall2.position.x = 435;
	                  krugerWall2.position.z = 500;
	                  krugerWall2.rotation.y = -125;

	                  var krugerMaterials3 = [
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshLambertMaterial({ }),
	                  new THREE.MeshBasicMaterial( { 
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/kruger3.png' )} )
	                  ];

	                  krugerWall3 = new THREE.Mesh(
	                  new THREE.CubeGeometry( 400, 600, 20),
	                  new THREE.MeshFaceMaterial( krugerMaterials3 ) );
	                  krugerWall3.position.y = 300;
	                  krugerWall3.position.x = 435;
	                  krugerWall3.position.z = 500;
	                  krugerWall3.rotation.y = -125;

	                  var krugerMaterials4 = [
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshLambertMaterial({ }),
	                  new THREE.MeshBasicMaterial( { 
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/kruger4.png' )} )
	                  ];

	                  krugerWall4 = new THREE.Mesh(
	                  new THREE.CubeGeometry( 400, 600, 20),
	                  new THREE.MeshFaceMaterial( krugerMaterials4 ) );
	                  krugerWall4.position.y = 300;
	                  krugerWall4.position.x = 435;
	                  krugerWall4.position.z = 500;
	                  krugerWall4.rotation.y = -125;


	                  var krugerMaterials5 = [
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshLambertMaterial({ }),
	                  new THREE.MeshBasicMaterial( { 
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/kruger5.png' )} )
	                  ];

	                  krugerWall5 = new THREE.Mesh(
	                  new THREE.CubeGeometry( 400, 600, 20),
	                  new THREE.MeshFaceMaterial( krugerMaterials5 ) );
	                  krugerWall5.position.y = 300;
	                  krugerWall5.position.x = 435;
	                  krugerWall5.position.z = 500;
	                  krugerWall5.rotation.y = -125;

	                  var krugerMaterials6 = [
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshBasicMaterial( { } ),
	                  new THREE.MeshLambertMaterial({ }),
	                  new THREE.MeshBasicMaterial( { 
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/kruger6.png' )} )
	                  ];

	                  krugerWall6 = new THREE.Mesh(
	                  new THREE.CubeGeometry( 400, 600, 20),
	                  new THREE.MeshFaceMaterial( krugerMaterials6 ) );
	                  krugerWall6.position.y = 300;
	                  krugerWall6.position.x = 435;
	                  krugerWall6.position.z = 500;
	                  krugerWall6.rotation.y = -125;
	         
	              function startTimer() {
	                  barbTimer = setInterval(barbAnimation, 0250); 
	              }

	              function barbAnimation() {
	                    if ( currentWall === 0 ) {
	                      scene.remove( krugerWall6 )
	                      scene.add( krugerWall );
	                      currentWall++;
	                    }   
	                    else if ( currentWall === 1 ) {
	                      scene.remove( krugerWall6 )
	                      scene.remove( krugerWall );
	                      scene.add( krugerWall2 );
	                      currentWall++;
	                    }             
	                    else if ( currentWall === 2 ) {
	                      scene.remove( krugerWall2 );
	                      scene.add( krugerWall3 );
	                      currentWall++;
	                    }  
	                    else if ( currentWall === 3 ) {
	                      scene.remove( krugerWall3 );
	                      scene.add( krugerWall4 );
	                      currentWall++;
	                    }  
	                    else if ( currentWall === 4 ) {
	                      scene.remove( krugerWall4 );
	                      scene.add( krugerWall5 );
	                      currentWall++;
	                    }
	                     else if ( currentWall === 5 ) {
	                      scene.remove( krugerWall5 );
	                      scene.add( krugerWall6 );
	                      window.currentWall = 0;
	                    }  
	                }
	                currentWall = 1;
	                startTimer();

	                 var krugerCardMaterials = [
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshBasicMaterial( {} ),
	                  new THREE.MeshLambertMaterial({}),
	                  new THREE.MeshBasicMaterial( {
	                      ambient: 0xffffff,
	                      map: THREE.ImageUtils.loadTexture( 'gallery_assets/textures/krugerCard.png' ) } )
	                ];

	                  krugerLabel = new THREE.Mesh(
	                  new THREE.CubeGeometry( 10, 5, 0.5),
	                  new THREE.MeshFaceMaterial( krugerCardMaterials ) );
	                  scene.add( krugerLabel );
	                  krugerLabel.position.y = 32.5;
	                  krugerLabel.position.x = 505;
	                  krugerLabel.position.z = 310;
	                  krugerLabel.rotation.y = -125; 

	            

	                  // ------- LAST FEMALE ARTIST -------//

	                whiteBox = new THREE.Mesh(
	                  new THREE.CubeGeometry( 20, 20, 20 ),
	                  new THREE.MeshBasicMaterial({}) );


	                for(var i = 0; i < 10; i++){ 
	                      var newModel = whiteBox.clone();
	                          newModel.position.set(i,i*4 +10,i);
	                          // newModel.scale.set(i+1,i+1,i+1);
	                          scene.add(newModel); 
	                }  


	                        // texture

	                  var manager = new THREE.LoadingManager();

	                  manager.onProgress = function ( item, loaded, total ) {

	                    console.log( item, loaded, total );

	                  };

	                  var texture = new THREE.Texture();


	                  var loader = new THREE.OBJLoader( manager );
	                  loader.load( 'gallery_assets/models/chair.obj', function ( object ) {

	                    object.traverse( function ( child ) {

	                      if ( child instanceof THREE.Mesh ) {

	                        child.material.map = texture;

	                      }

	                    } );

	                    object.position.y = - 80;
	                    scene.add( object );

	                  } );



	                  // loader.addEventListener( 'load', function ( event ) {
	                      
	                  //     // for ( var i = 0; i < 10; i ++ ) {
	                  //     var object = event.content;
	                  //     scene.add( object );
	                  //     object.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
	                  //     object.position.y = Math.floor( Math.random() * 20 ) * 20 + 10;
	                  //     object.position.z = Math.floor( Math.random() * 20 - 10 ) * 20;
	                      
	                  //   // }
	                  // });
	                  // loader.load( 'models/Rmutt.obj', 'models/Rmutt.mtl' )


	          // }

	                }


	                //////////////////////////////
	                //** --    ANIMATION --   **//
	                //////////////////////////////


	                function animate() {
	                    requestAnimationFrame( animate );
	                    controls.isOnObject( false );
	                    ray.ray.origin.copy( controls.getObject().position );
	                    ray.ray.origin.y -= 10;  
	                    ray.ray.origin.z -= 10;  
	                    var intersections = ray.intersectObjects( objects );
	                    if ( intersections.length > 0 ) {
	                        var distance = intersections[ 0 ].distance;
	                        if ( distance > 0 && distance < 10 ) {
	                            controls.isOnObject( true );
	                        }
	                    }
	                    controls.update( Date.now() - time );
	                    renderer.render( scene, camera );
	                    time = Date.now();
	                }



	                //////////////////////////////////
	                //** --    WINDOW EVENTS --   **//
	                //////////////////////////////////

	                renderer = new THREE.WebGLRenderer({
	                          preserveDrawingBuffer : true  // to allow screenshot
	                });

	                renderer.setSize( window.innerWidth, window.innerHeight );

	                document.body.appendChild( renderer.domElement );
	                window.addEventListener( 'resize', onWindowResize, false );


	                function onWindowResize() {
	                  camera.aspect = window.innerWidth / window.innerHeight;
	                  camera.updateProjectionMatrix();
	                  renderer.setSize( window.innerWidth, window.innerHeight );
	                }

	                init();
	                animate();
	                THREEx.Screenshot.bindKey(renderer);
	    }

	       </script>

		</script>

	</body>
</html>
